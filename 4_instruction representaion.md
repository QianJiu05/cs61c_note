在汇编中看到的加载字和存储字操作都是对内存中的32位的字操作的

每个寄存器都是一个32bit的word

lw和sw每次都访问1 word

RISC-V追求简洁，使指令成为固定大小的 32 位字，那么同样的指令就可以用于RV32，RV64，RV128

可以定义不同指令的不同布局，以下是六个基础指令格式：

1. R格式，reg-reg 逻辑操作
2. I格式，reg-imm 
3. S格式，用于存储
4. B格式，用于分支（S格式的小变体）
5. U格式，用于20bit高位立即数指令
6. J格式，用于jump（U格式的小变体）
   
# R格式
```
31--25 24--20 19--15 14--12 11--7 6--0
funct7  rs2    rs1   funct3  rd   opcode
   7     5      5      3      5      7
opcode: 0110 0011
funct7 + funct3 : 和opcode配合，描述了要进行什么操作
所有R指令有相同的opcode
rd：destination reg 目标寄存器
rs：source reg 源寄存器

eg： add x18,x19,x10
31--25   24--20   19--15 14--12 11--7   6--0
0000000   01010   10011   000   10010   0110 011
   7      5        5       3      5      7
funct7    rs2     rs1   funct3   rd    opcode
rs1=19,rs2=10(源寄存器),rd=18
```
| 31--25 | 24--20 | 19--15 | 14--12 | 11--7 | 6--0 | |
|:------|-------|-------|-------|-------|-------|-------|
|0000 000|rs2|rs1|000|rs|011 0011|add|
|**0100 000**|rs2|rs1|000|rs|011 0011|sub|
|0000 000|rs2|rs1|001|rs|011 0011|sll|
|0000 000|rs2|rs1|010|rs|011 0011|slt|
|0000 000|rs2|rs1|011|rs|011 0011|sltu|
|0000 000|rs2|rs1|100|rs|011 0011|xor|
|0000 000|rs2|rs1|101|rs|011 0011|srl|
|**0100 000**|rs2|rs1|101|rs|011 0011|sra|
|0000 000|rs2|rs1|110|rs|011 0011|or|
|0000 000|rs2|rs1|111|rs|011 0011|and|

slt：set on less len：比较寄存器，结果是小的那个

减法只是用二进制补码加法，不需要额外硬件，sub与add只在funct7上有差异

sra shift right arithmetic 算数右移,与srl只在funct7上有差异，那一位=1意味着符号扩展
# I格式
立即数的范围覆盖4096个值
符号扩展，把立即数最高有效位拓展到所有最高有效位
```
31--20   19--15 14--12 11--7 6--0
imm[11:0] rs1   funct3  rd   opcode
```
| 31--20 | 19--15 | 14--12 | 11--7 | 6--0 | |
|:------|-------|-------|-------|-------|-------|
|imm[11:0]|rs1|000|rd|0010 011|addi|
|imm[11:0]|rs1|010|rd|0010 011|slti|
|imm[11:0]|rs1|011|rd|0010 011|sltiu|
|imm[11:0]|rs1|100|rd|0010 011|xori|
|imm[11:0]|rs1|110|rd|0010 011|ori|
|imm[11:0]|rs1|111|rd|0010 011|andi|
|0000 000,shamt|rs1|001|rd|0010 011|slli|
|0000 000,shamt|rs1|101|rd|0010 011|srli|
|0100 000,shamt|rs1|000|rd|0010 011|srai|
最后三条指令，移位量限制为5，超出5的部分没有意义了

高位bit 1是为了区分srli和srai

1. 逻辑右移（srl）

    定义：逻辑右移将二进制数的每一位向右移动指定的位数，空出的位用0填充。

    用途：逻辑右移通常用于无符号数的右移操作。

    行为：
    对于正数和负数，逻辑右移都会在左边填充0。

2. 算术右移（sra）

    定义：算术右移将二进制数的每一位向右移动指定的位数，空出的位用符号位（最高位）的值填充。

    用途：算术右移通常用于有符号数的右移操作，以保持数的符号不变。

    行为：对于正数，算术右移在左边填充0。
对于负数，算术右移在左边填充1。
## loads
| 31--20 | 19--15 | 14--12 | 11--7 | 6--0 | ||
|:------|-------|-------|-------|-------|-------|-------|
|imm[11:0]|rs1|000|rd|0000 011|lb|load byte|
|imm[11:0]|rs1|001|rd|0000 011|lh|load halfword|
|imm[11:0]|rs1|010|rd|0000 011|lw|load word|
|imm[11:0]|rs1|100|rd|0000 011|lbu|load usigned byte|
|imm[11:0]|rs1|101|rd|0000 011|lhu|load usigned halfword|

lw\lh:把字节复制到低地址然后符号扩展
# S格式
我们总是希望寄存器在指令的中间位置，不用让处理器找寄存器位置，所以分割的是立即数位段
```
31--25   24--20 19--15 14--12  11--7    6--0
Imm[11:5] rs2    rs1   funct3 imm[4:0] opcode
   7       5      5       4     5         7
```
| 31--25 | 24--20 | 19--15 | 14--12 | 11--7 |  6--0 ||
|:------|-------|-------|-------|-------|-------|-------|
|Imm[11:5]|rs2|rs1|000|Imm[4:0] |0100 011|sb|
|Imm[11:5]|rs2|rs1|001|Imm[4:0] |0100 011|sh|
|Imm[11:5]|rs2|rs1|010|Imm[4:0] |0100 011|sw|
从上到下分别是byte\halfword\word

# B格式
分支通常用于循环（if-else\while\for）

循环通常小于50条指令，函数调用和非条件条约使用J格式处理

复习：指令存储在本地内存区域中（Code、Text）

>大分支距离受代码大小限制
>
>当前指令地址存储在program counter（PC）

PC相对寻址：使用立即数作为 PC 的二进制补码偏移量
1. 分支通常改变少量PC值
2. 从PC可以识别+-2^11 个单位地址

不使用byte而用word作为单位偏移量：指令时4byte长的，不希望跳转到指令的中间

压缩指令集是指令集架构的一个子集，有16位指令:

>RISC-V指令集架构（ISA）的扩展，支持16位压缩指令以及长度为16位倍数的可变长度指令。
>
>为了实现这一点，RISC-V将分支偏移量放大了2字节，即使没有16位指令也是如此。
>
>这将分支范围减少了一半，这意味着在只支持32位指令的RISC-V处理器上，只有一半的可能目标会出现错误（如本类中使用的）。
>
>RISC-V的条件分支只能达到± (2^10) × 32位指令的范围，无论是在程序计数器（PC）的哪一侧。

实际操作时以2字节为单位进行计算
```
don't: PC =PC + 4

do: PC = PC + imm * 2
```
```
  31     30--25  34--20 19--15 14--12 11--8      7     6--0
imm[12] imm[10:5] rs2    rs1   funct3 imm[4:1] imm[11] opcode

```
B格式基本与S格式一致，有两个reg source，一个12bit的立即数

但是B格式的立即数能表示-4096 ~~ +4096
```

Loop beq x19,x10,End  
     add x18,x19,-1   
     j Loop
End:
```
branch offset: 4 x 32bit instruction = 16 bytes

如果branch的offset = 0，那么就是自己

| |  |  |  |  |   ||
|:------|-------|-------|-------|-------|-------|-------|
|Imm[12\|10:5]|rs2|rs1|000|Imm[4:1\|11] |1100 011|beq|
|Imm[12\|10:5]|rs2|rs1|100|Imm[4:1\|11] |1100 011|bne|
|Imm[12\|10:5]|rs2|rs1|101|Imm[4:1\|11] |1100 011|blt|
|Imm[12\|10:5]|rs2|rs1|110|Imm[4:1\|11] |1100 011|bge|
|Imm[12\|10:5]|rs2|rs1|111|Imm[4:1\|11] |1100 011|bltu|
|Imm[12\|10:5]|rs2|rs1|111|Imm[4:1\|11] |1100 011|bgeu|
# long immediates
当前的立即数都只有12bit，如果要将32bit都作为立即数应该怎么做

在移动代码时分支指令立即字段中的值是否会变化:
1. 如果移动单行代码，那么是的，值会变化。
2. 如果移动所有代码，则不会变化（“位置无关代码”）。PC相对寻址概念
   
如果我们的目标距离分支指令超过 2^10 指令单位（要跳转的距离超过分支指令可容纳的距离），我们该怎么办？

其他指令可以解决这个问题:用bne而不是beq进行条件判断
```
beq x10,x0,far
#next instr

==>

    bne x10,x0,next
    j far
next: next instr
```
例如，使用 beq x10,x0,far 指令，其中 # next instr 表示下一条指令的位置，可以替换为 bne x10,x0,next 然后跳转到 j far，其中 next: 表示下一条指令的位置。
# U格式
```
31--12      11--7 6--0
imm[31:12]  rd    opcode
  20        5       7

imm[31:12]  dest  LUI：load upper imme加载上部立即数到rd中，置零低12bit
imm[31:12]  dest  AUIPC：add upper imme to PC把立即数加载到PC里
```
重用了func7字段
```
写DEADBEEF：
lui x10 0xDEADB #x10 = 0xDEADB000
addi x10,x10,0xEEF #x10 = 0xDEADAEEF
addi是符号拓展的，导致B-1变成了A
riscv没有无符号的立即数加法指令

所以应该
lui x10,0xDEADC
addi x10,x10,0xEEF

==>
伪指令自动处理高位+1的过程：
li x10,0xDEADBEEF
```
# J格式
```
31      30--21      20      19--12  11--7 6--0
imm[20] imm[10:1] imm[11] imm[19:12] rd  opcode
1         10        1          8      5     7
```
不保存返回地址的伪指令j：会把rd指定为x0
`j Lable = jal x0,Label #丢弃了返回地址`

`jal ra，FuncName`

## JALR指令：I格式
```
31--20   19--15 14--12  11--7 6--0
imm[11:0] rs1    func3   rd  opcode
12         5       3     5     7
offset    base     0    dest  JALR
```
`jalr rd,rs,imm`
1. 写入PC+4到rd（return addr）
2. 设置PC = rs —— imm
   
用的是和arithmetic和loads相同的立即数：不是以2byte为单位的（与jal和branch不同）
```
#ret 和 jr的伪指令
    ret = jr 
    ra = jalr x0,ra,0

# 调用函数（32bit绝对地址）
    lui x1,<high 20 bits>
    jalr ra,x1,<low 12 bits>

# PC相对寻址（32bit）
    auipc x1,<high 20 bits>
    jalr x0,x1,<low 12 bits>