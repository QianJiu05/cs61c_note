# assembly language
CPU的工作就是执行指令。不同的CPU执行不同的指令集。特定实现的指令集是ISA（Instruction Set Architecture，指令集架构）

RISC：让指令短，可以在一周期内运行更多的指令。让软件通过组织简单指令来执行复杂的操作

CISC本质是RISC构建引擎，复杂指令在机器内部连接简单指令

指令集是一种特定的体系结构可以执行的指令集合

每行汇编代码代表一条计算器的指令。

一个4Ghz的CPU每0.25ns就可以访问一次寄存器

汇编没有变量，所有的操作都是对于寄存器的。非常快！

处理器通过发出地址，从内存读取数据或向内存写入数据来与内存通信

所有内存系统的目标都是使内存看起来无限快且无限大。由于只有很少的寄存器，希望让大部分内存看起来像寄存器一样快速
# RISC-V
RISC-V有32个寄存器，每个寄存器都是32bit的

32bit：1 word in RV32

在RV32中，每个字4字节，32位（bit） 字的宽度与架构变种相关联

汇编没有变量，操作它们的操作（指令中的动词）决定了实际上如何处理寄存器的内容。每行最多一条汇编指令

x0永远=0，因为总是需要用到0

## add assembly
add x1,x2,x3 --> a = b + c: x1=a,x2=b,x3=c -->x1 = x2 + x3

sub x3,x4,x5 --> x3 = x4 - x5

```
f=(g+h)-(i+j)
add x5,x20,x21 # a_temp = g+h
add x6,x22,x23
sub x19,x5,x6 # f = a_temp - b_temp
```
常数是立即数，`addi x3,x4,10 : x3 = x4 + 10`

减法：把立即数设置为负值，用补码表示，`addi x3,x4,-10`

把x4的内容移动到x3:`add x3,x4,x0`前文提到x0永远是0

优化编译器的使用通常是最小化寄存器的使用。对于特定内核使用的寄存器数量称为该内核的寄存器足迹

地址通常是基地址的偏移量。
数据存储到内存，从内存中加载

## memory address
数据一般小于32bits，大于8bits：如果所有东西都是8bits的倍数，处理器处理起来会比较方便

`8 bits = 1 byte`
`1 word = 4 byte = 4*8 bits`

每个32位的word可以容纳4个bytes

RISC-V是小端序的，最低有效字节获得最低的字节地址

如图所示内存片段：

| 31-24 | BYTE2 | BYTE1 | BYTE0 | 字的地址 |
|:------|-------|-------|-------|-------|
|15|14|13|12|[12]，第四个word|
|11|10|9|8|[8]，第三个word|
|7|6|5|4|[4]，第二个word|
|3|2|1|0|[0]，第一个word|

读取顺序：0-3，4-7，...

从下到上，word的地址分别是0，4，8，12。本质上字的地址与其最低的有效字节的地址相同

对于这么一个数字：
| BYTE3 | BYTE2 | BYTE1 | **BYTE0** | 
|:------|-------|-------|-------|
| 00000000 | 00000000 | 00000100 | **00000001** | 
大端表示：
| ADDR3 | ADDR2 | ADDR1 | ADDR0 | 
| **BYTE0** | BYTE1 | BYTE2 | BYTE3 | 
| **00000001** |  00000100 | 00000000 | 00000000 |
小端表示：
| ADDR3 | ADDR2 | ADDR1 | ADDR0 | 
| BYTE3 | BYTE2 | BYTE1 | **BYTE0** | 
| 00000000 | 00000000 | 00000100 | **00000001** | 

## 数据转移指令
lw：load word

方向：从内存到寄存器

偏移是以字节（byte）为单位的

`g = h + A[3]` -->
```
lw x10,12(x15) # x10获得A[3],12是A偏移3word，3*4=12 bytes。x15是A[0]的指针

add x11,x12,x10 # g = h + A[3]
```
sw：store word

方向：从寄存器到内存
